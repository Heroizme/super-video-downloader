name: ğŸ” Auto Sync upstream Releases

on:
  schedule:
    - cron: '0 2 * * *'      # æ¯å¤© UTC 2:00ï¼ˆåŒ—äº¬æ—¶é—´ 10:00ï¼‰
  workflow_dispatch:         # å¯æ‰‹åŠ¨è§¦å‘

permissions:
  contents: write            # åˆ›å»º Release éœ€è¦å†™æƒé™

jobs:
  sync_releases:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout (for context)
        uses: actions/checkout@v3

      - name: Install node-fetch polyfill
        run: npm install node-fetch@2

      - name: Sync Releases from upstream
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fetch = require('node-fetch');  // ç”¨äºä¸‹è½½äºŒè¿›åˆ¶é™„ä»¶

            // è·å–å½“å‰ä»“åº“ä¿¡æ¯ï¼Œè‡ªåŠ¨è¯†åˆ« upstream
            const repoInfo = await github.rest.repos.get({
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            if (!repoInfo.data.fork || !repoInfo.data.parent) {
              throw new Error('âŒ å½“å‰ä»“åº“ä¸æ˜¯ Fork ä»“åº“ï¼Œæ— æ³•è‡ªåŠ¨è¯†åˆ« upstreamã€‚\nè¯·æ‰‹åŠ¨è®¾ç½® upstreamOwner å’Œ upstreamRepoã€‚');
            }

            const upstreamOwner = repoInfo.data.parent.owner.login;
            const upstreamRepo  = repoInfo.data.parent.name;
            const myOwner       = context.repo.owner;
            const myRepo        = context.repo.repo;

            console.log(`ğŸ” Upstream detected: ${upstreamOwner}/${upstreamRepo}`);

            // è·å–ä¸Šæ¸¸æ‰€æœ‰ releases
            const upstreamReleases = await github.rest.repos.listReleases({
              owner: upstreamOwner,
              repo: upstreamRepo,
              per_page: 100
            });

            for (const rel of upstreamReleases.data) {
              // æ£€æŸ¥æœ¬åœ°æ˜¯å¦å·²æœ‰è¯¥ release
              let exists = true;
              try {
                await github.rest.repos.getReleaseByTag({
                  owner: myOwner,
                  repo: myRepo,
                  tag: rel.tag_name
                });
              } catch {
                exists = false;
              }

              if (!exists) {
                // åˆ›å»º release
                const created = await github.rest.repos.createRelease({
                  owner: myOwner,
                  repo: myRepo,
                  tag_name: rel.tag_name,
                  name: rel.name,
                  body: rel.body,
                  draft: rel.draft,
                  prerelease: rel.prerelease
                });
                console.log(`âœ… Created release ${rel.tag_name}`);

                // ä¸‹è½½å¹¶ä¸Šä¼ æ¯ä¸ªé™„ä»¶
                const assets = await github.rest.repos.listReleaseAssets({
                  owner: upstreamOwner,
                  repo: upstreamRepo,
                  release_id: rel.id
                });

                for (const asset of assets.data) {
                  const response = await fetch(asset.url, {
                    headers: {
                      accept: 'application/octet-stream',
                      'user-agent': 'github-script'
                    }
                  });

                  const arrayBuffer = await response.arrayBuffer();

                  await github.rest.repos.uploadReleaseAsset({
                    owner: myOwner,
                    repo: myRepo,
                    release_id: created.data.id,
                    name: asset.name,
                    data: Buffer.from(arrayBuffer)
                  });

                  console.log(`  + ğŸ—‚ï¸  Synced asset: ${asset.name}`);
                }
              } else {
                console.log(`â­ï¸ Release ${rel.tag_name} already exists, skipping.`);
              }
            }
